// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: coordinator.proto

package protogen

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on RegisterWorkerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegisterWorkerRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterWorkerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterWorkerRequestMultiError, or nil if none found.
func (m *RegisterWorkerRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterWorkerRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Port

	if len(errors) > 0 {
		return RegisterWorkerRequestMultiError(errors)
	}

	return nil
}

// RegisterWorkerRequestMultiError is an error wrapping multiple validation
// errors returned by RegisterWorkerRequest.ValidateAll() if the designated
// constraints aren't met.
type RegisterWorkerRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterWorkerRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterWorkerRequestMultiError) AllErrors() []error { return m }

// RegisterWorkerRequestValidationError is the validation error returned by
// RegisterWorkerRequest.Validate if the designated constraints aren't met.
type RegisterWorkerRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterWorkerRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterWorkerRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterWorkerRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterWorkerRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterWorkerRequestValidationError) ErrorName() string {
	return "RegisterWorkerRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterWorkerRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterWorkerRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterWorkerRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterWorkerRequestValidationError{}

// Validate checks the field values on DeregisterWorkerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeregisterWorkerRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeregisterWorkerRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeregisterWorkerRequestMultiError, or nil if none found.
func (m *DeregisterWorkerRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeregisterWorkerRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return DeregisterWorkerRequestMultiError(errors)
	}

	return nil
}

// DeregisterWorkerRequestMultiError is an error wrapping multiple validation
// errors returned by DeregisterWorkerRequest.ValidateAll() if the designated
// constraints aren't met.
type DeregisterWorkerRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeregisterWorkerRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeregisterWorkerRequestMultiError) AllErrors() []error { return m }

// DeregisterWorkerRequestValidationError is the validation error returned by
// DeregisterWorkerRequest.Validate if the designated constraints aren't met.
type DeregisterWorkerRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeregisterWorkerRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeregisterWorkerRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeregisterWorkerRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeregisterWorkerRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeregisterWorkerRequestValidationError) ErrorName() string {
	return "DeregisterWorkerRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeregisterWorkerRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeregisterWorkerRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeregisterWorkerRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeregisterWorkerRequestValidationError{}

// Validate checks the field values on HeartbeatRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *HeartbeatRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HeartbeatRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HeartbeatRequestMultiError, or nil if none found.
func (m *HeartbeatRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *HeartbeatRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Port

	if len(errors) > 0 {
		return HeartbeatRequestMultiError(errors)
	}

	return nil
}

// HeartbeatRequestMultiError is an error wrapping multiple validation errors
// returned by HeartbeatRequest.ValidateAll() if the designated constraints
// aren't met.
type HeartbeatRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HeartbeatRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HeartbeatRequestMultiError) AllErrors() []error { return m }

// HeartbeatRequestValidationError is the validation error returned by
// HeartbeatRequest.Validate if the designated constraints aren't met.
type HeartbeatRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HeartbeatRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HeartbeatRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HeartbeatRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HeartbeatRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HeartbeatRequestValidationError) ErrorName() string { return "HeartbeatRequestValidationError" }

// Error satisfies the builtin error interface
func (e HeartbeatRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHeartbeatRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HeartbeatRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HeartbeatRequestValidationError{}

// Validate checks the field values on HeartbeatResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *HeartbeatResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HeartbeatResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HeartbeatResponseMultiError, or nil if none found.
func (m *HeartbeatResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *HeartbeatResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if len(errors) > 0 {
		return HeartbeatResponseMultiError(errors)
	}

	return nil
}

// HeartbeatResponseMultiError is an error wrapping multiple validation errors
// returned by HeartbeatResponse.ValidateAll() if the designated constraints
// aren't met.
type HeartbeatResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HeartbeatResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HeartbeatResponseMultiError) AllErrors() []error { return m }

// HeartbeatResponseValidationError is the validation error returned by
// HeartbeatResponse.Validate if the designated constraints aren't met.
type HeartbeatResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HeartbeatResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HeartbeatResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HeartbeatResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HeartbeatResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HeartbeatResponseValidationError) ErrorName() string {
	return "HeartbeatResponseValidationError"
}

// Error satisfies the builtin error interface
func (e HeartbeatResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHeartbeatResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HeartbeatResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HeartbeatResponseValidationError{}

// Validate checks the field values on WorkerStreamStatusRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WorkerStreamStatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WorkerStreamStatusRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WorkerStreamStatusRequestMultiError, or nil if none found.
func (m *WorkerStreamStatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *WorkerStreamStatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WorkerStreamId

	// no validation rules for Status

	if len(errors) > 0 {
		return WorkerStreamStatusRequestMultiError(errors)
	}

	return nil
}

// WorkerStreamStatusRequestMultiError is an error wrapping multiple validation
// errors returned by WorkerStreamStatusRequest.ValidateAll() if the
// designated constraints aren't met.
type WorkerStreamStatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkerStreamStatusRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkerStreamStatusRequestMultiError) AllErrors() []error { return m }

// WorkerStreamStatusRequestValidationError is the validation error returned by
// WorkerStreamStatusRequest.Validate if the designated constraints aren't met.
type WorkerStreamStatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkerStreamStatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkerStreamStatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkerStreamStatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkerStreamStatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkerStreamStatusRequestValidationError) ErrorName() string {
	return "WorkerStreamStatusRequestValidationError"
}

// Error satisfies the builtin error interface
func (e WorkerStreamStatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkerStreamStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkerStreamStatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkerStreamStatusRequestValidationError{}

// Validate checks the field values on ListWorkersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListWorkersRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListWorkersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListWorkersRequestMultiError, or nil if none found.
func (m *ListWorkersRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListWorkersRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _ListWorkersRequest_Status_InLookup[m.GetStatus()]; !ok {
		err := ListWorkersRequestValidationError{
			field:  "Status",
			reason: "value must be in list [active inactive all]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListWorkersRequestMultiError(errors)
	}

	return nil
}

// ListWorkersRequestMultiError is an error wrapping multiple validation errors
// returned by ListWorkersRequest.ValidateAll() if the designated constraints
// aren't met.
type ListWorkersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWorkersRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWorkersRequestMultiError) AllErrors() []error { return m }

// ListWorkersRequestValidationError is the validation error returned by
// ListWorkersRequest.Validate if the designated constraints aren't met.
type ListWorkersRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWorkersRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWorkersRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWorkersRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWorkersRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWorkersRequestValidationError) ErrorName() string {
	return "ListWorkersRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListWorkersRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWorkersRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWorkersRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWorkersRequestValidationError{}

var _ListWorkersRequest_Status_InLookup = map[string]struct{}{
	"active":   {},
	"inactive": {},
	"all":      {},
}

// Validate checks the field values on ListWorkersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListWorkersResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListWorkersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListWorkersResponseMultiError, or nil if none found.
func (m *ListWorkersResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListWorkersResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListWorkersResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListWorkersResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListWorkersResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListWorkersResponseMultiError(errors)
	}

	return nil
}

// ListWorkersResponseMultiError is an error wrapping multiple validation
// errors returned by ListWorkersResponse.ValidateAll() if the designated
// constraints aren't met.
type ListWorkersResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWorkersResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWorkersResponseMultiError) AllErrors() []error { return m }

// ListWorkersResponseValidationError is the validation error returned by
// ListWorkersResponse.Validate if the designated constraints aren't met.
type ListWorkersResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWorkersResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWorkersResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWorkersResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWorkersResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWorkersResponseValidationError) ErrorName() string {
	return "ListWorkersResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListWorkersResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWorkersResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWorkersResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWorkersResponseValidationError{}

// Validate checks the field values on ListStreamsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListStreamsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListStreamsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListStreamsRequestMultiError, or nil if none found.
func (m *ListStreamsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListStreamsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _ListStreamsRequest_Status_InLookup[m.GetStatus()]; !ok {
		err := ListStreamsRequestValidationError{
			field:  "Status",
			reason: "value must be in list [active completed paused failed all]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListStreamsRequestMultiError(errors)
	}

	return nil
}

// ListStreamsRequestMultiError is an error wrapping multiple validation errors
// returned by ListStreamsRequest.ValidateAll() if the designated constraints
// aren't met.
type ListStreamsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListStreamsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListStreamsRequestMultiError) AllErrors() []error { return m }

// ListStreamsRequestValidationError is the validation error returned by
// ListStreamsRequest.Validate if the designated constraints aren't met.
type ListStreamsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListStreamsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListStreamsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListStreamsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListStreamsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListStreamsRequestValidationError) ErrorName() string {
	return "ListStreamsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListStreamsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListStreamsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListStreamsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListStreamsRequestValidationError{}

var _ListStreamsRequest_Status_InLookup = map[string]struct{}{
	"active":    {},
	"completed": {},
	"paused":    {},
	"failed":    {},
	"all":       {},
}

// Validate checks the field values on ListStreamsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListStreamsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListStreamsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListStreamsResponseMultiError, or nil if none found.
func (m *ListStreamsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListStreamsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListStreamsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListStreamsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListStreamsResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListStreamsResponseMultiError(errors)
	}

	return nil
}

// ListStreamsResponseMultiError is an error wrapping multiple validation
// errors returned by ListStreamsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListStreamsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListStreamsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListStreamsResponseMultiError) AllErrors() []error { return m }

// ListStreamsResponseValidationError is the validation error returned by
// ListStreamsResponse.Validate if the designated constraints aren't met.
type ListStreamsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListStreamsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListStreamsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListStreamsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListStreamsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListStreamsResponseValidationError) ErrorName() string {
	return "ListStreamsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListStreamsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListStreamsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListStreamsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListStreamsResponseValidationError{}

// Validate checks the field values on GetStreamRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetStreamRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetStreamRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetStreamRequestMultiError, or nil if none found.
func (m *GetStreamRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetStreamRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetStreamRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetStreamRequestMultiError(errors)
	}

	return nil
}

// GetStreamRequestMultiError is an error wrapping multiple validation errors
// returned by GetStreamRequest.ValidateAll() if the designated constraints
// aren't met.
type GetStreamRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetStreamRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetStreamRequestMultiError) AllErrors() []error { return m }

// GetStreamRequestValidationError is the validation error returned by
// GetStreamRequest.Validate if the designated constraints aren't met.
type GetStreamRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetStreamRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetStreamRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetStreamRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetStreamRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetStreamRequestValidationError) ErrorName() string { return "GetStreamRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetStreamRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetStreamRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetStreamRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetStreamRequestValidationError{}

// Validate checks the field values on StreamResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StreamResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StreamResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StreamResponseMultiError,
// or nil if none found.
func (m *StreamResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StreamResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StreamResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StreamResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StreamResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StreamResponseValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StreamResponseValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StreamResponseValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StreamResponseMultiError(errors)
	}

	return nil
}

// StreamResponseMultiError is an error wrapping multiple validation errors
// returned by StreamResponse.ValidateAll() if the designated constraints
// aren't met.
type StreamResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StreamResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StreamResponseMultiError) AllErrors() []error { return m }

// StreamResponseValidationError is the validation error returned by
// StreamResponse.Validate if the designated constraints aren't met.
type StreamResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StreamResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StreamResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StreamResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StreamResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StreamResponseValidationError) ErrorName() string { return "StreamResponseValidationError" }

// Error satisfies the builtin error interface
func (e StreamResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStreamResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StreamResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StreamResponseValidationError{}

// Validate checks the field values on Event with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Event) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Event with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EventMultiError, or nil if none found.
func (m *Event) ValidateAll() error {
	return m.validate(true)
}

func (m *Event) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WorkerStreamId

	// no validation rules for Section

	// no validation rules for ComponentLabel

	if _, ok := _Event_Type_InLookup[m.GetType()]; !ok {
		err := EventValidationError{
			field:  "Type",
			reason: "value must be in list [PRODUCE CONSUME DELETE ERROR UNKNOWN]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Content

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EventValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EventValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EventValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for FlowId

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EventValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EventValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EventValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EventMultiError(errors)
	}

	return nil
}

// EventMultiError is an error wrapping multiple validation errors returned by
// Event.ValidateAll() if the designated constraints aren't met.
type EventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventMultiError) AllErrors() []error { return m }

// EventValidationError is the validation error returned by Event.Validate if
// the designated constraints aren't met.
type EventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventValidationError) ErrorName() string { return "EventValidationError" }

// Error satisfies the builtin error interface
func (e EventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventValidationError{}

var _Event_Type_InLookup = map[string]struct{}{
	"PRODUCE": {},
	"CONSUME": {},
	"DELETE":  {},
	"ERROR":   {},
	"UNKNOWN": {},
}

// Validate checks the field values on ListEventsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListEventsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListEventsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListEventsRequestMultiError, or nil if none found.
func (m *ListEventsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListEventsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetStreamId() <= 0 {
		err := ListEventsRequestValidationError{
			field:  "StreamId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Limit

	// no validation rules for Offset

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListEventsRequestValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListEventsRequestValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListEventsRequestValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEndTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListEventsRequestValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListEventsRequestValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListEventsRequestValidationError{
				field:  "EndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListEventsRequestMultiError(errors)
	}

	return nil
}

// ListEventsRequestMultiError is an error wrapping multiple validation errors
// returned by ListEventsRequest.ValidateAll() if the designated constraints
// aren't met.
type ListEventsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListEventsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListEventsRequestMultiError) AllErrors() []error { return m }

// ListEventsRequestValidationError is the validation error returned by
// ListEventsRequest.Validate if the designated constraints aren't met.
type ListEventsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListEventsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListEventsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListEventsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListEventsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListEventsRequestValidationError) ErrorName() string {
	return "ListEventsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListEventsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListEventsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListEventsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListEventsRequestValidationError{}

// Validate checks the field values on ListEventsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListEventsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListEventsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListEventsResponseMultiError, or nil if none found.
func (m *ListEventsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListEventsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListEventsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListEventsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListEventsResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Total

	if len(errors) > 0 {
		return ListEventsResponseMultiError(errors)
	}

	return nil
}

// ListEventsResponseMultiError is an error wrapping multiple validation errors
// returned by ListEventsResponse.ValidateAll() if the designated constraints
// aren't met.
type ListEventsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListEventsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListEventsResponseMultiError) AllErrors() []error { return m }

// ListEventsResponseValidationError is the validation error returned by
// ListEventsResponse.Validate if the designated constraints aren't met.
type ListEventsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListEventsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListEventsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListEventsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListEventsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListEventsResponseValidationError) ErrorName() string {
	return "ListEventsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListEventsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListEventsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListEventsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListEventsResponseValidationError{}

// Validate checks the field values on MetricsRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MetricsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetricsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MetricsRequestMultiError,
// or nil if none found.
func (m *MetricsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MetricsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetWorkerStreamId() <= 0 {
		err := MetricsRequestValidationError{
			field:  "WorkerStreamId",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for InputEvents

	// no validation rules for ProcessorErrors

	// no validation rules for OutputEvents

	// no validation rules for InputEventsByComponent

	// no validation rules for ProcessorEventsByComponent

	// no validation rules for OutputEventsByComponent

	if len(errors) > 0 {
		return MetricsRequestMultiError(errors)
	}

	return nil
}

// MetricsRequestMultiError is an error wrapping multiple validation errors
// returned by MetricsRequest.ValidateAll() if the designated constraints
// aren't met.
type MetricsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetricsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetricsRequestMultiError) AllErrors() []error { return m }

// MetricsRequestValidationError is the validation error returned by
// MetricsRequest.Validate if the designated constraints aren't met.
type MetricsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetricsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetricsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetricsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetricsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetricsRequestValidationError) ErrorName() string { return "MetricsRequestValidationError" }

// Error satisfies the builtin error interface
func (e MetricsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetricsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetricsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetricsRequestValidationError{}

// Validate checks the field values on SecretRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SecretRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecretRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SecretRequestMultiError, or
// nil if none found.
func (m *SecretRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SecretRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Value

	if len(errors) > 0 {
		return SecretRequestMultiError(errors)
	}

	return nil
}

// SecretRequestMultiError is an error wrapping multiple validation errors
// returned by SecretRequest.ValidateAll() if the designated constraints
// aren't met.
type SecretRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecretRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecretRequestMultiError) AllErrors() []error { return m }

// SecretRequestValidationError is the validation error returned by
// SecretRequest.Validate if the designated constraints aren't met.
type SecretRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecretRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecretRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecretRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecretRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecretRequestValidationError) ErrorName() string { return "SecretRequestValidationError" }

// Error satisfies the builtin error interface
func (e SecretRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecretRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecretRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecretRequestValidationError{}

// Validate checks the field values on ListSecretsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListSecretsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListSecretsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListSecretsResponseMultiError, or nil if none found.
func (m *ListSecretsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListSecretsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListSecretsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListSecretsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListSecretsResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListSecretsResponseMultiError(errors)
	}

	return nil
}

// ListSecretsResponseMultiError is an error wrapping multiple validation
// errors returned by ListSecretsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListSecretsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSecretsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSecretsResponseMultiError) AllErrors() []error { return m }

// ListSecretsResponseValidationError is the validation error returned by
// ListSecretsResponse.Validate if the designated constraints aren't met.
type ListSecretsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSecretsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSecretsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSecretsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSecretsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSecretsResponseValidationError) ErrorName() string {
	return "ListSecretsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListSecretsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSecretsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSecretsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSecretsResponseValidationError{}

// Validate checks the field values on SecretResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SecretResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecretResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SecretResponseMultiError,
// or nil if none found.
func (m *SecretResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SecretResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SecretResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SecretResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SecretResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SecretResponseValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SecretResponseValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SecretResponseValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SecretResponseMultiError(errors)
	}

	return nil
}

// SecretResponseMultiError is an error wrapping multiple validation errors
// returned by SecretResponse.ValidateAll() if the designated constraints
// aren't met.
type SecretResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecretResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecretResponseMultiError) AllErrors() []error { return m }

// SecretResponseValidationError is the validation error returned by
// SecretResponse.Validate if the designated constraints aren't met.
type SecretResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecretResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecretResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecretResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecretResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecretResponseValidationError) ErrorName() string { return "SecretResponseValidationError" }

// Error satisfies the builtin error interface
func (e SecretResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecretResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecretResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecretResponseValidationError{}

// Validate checks the field values on ListCachesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCachesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCachesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCachesResponseMultiError, or nil if none found.
func (m *ListCachesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCachesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListCachesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListCachesResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListCachesResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListCachesResponseMultiError(errors)
	}

	return nil
}

// ListCachesResponseMultiError is an error wrapping multiple validation errors
// returned by ListCachesResponse.ValidateAll() if the designated constraints
// aren't met.
type ListCachesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCachesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCachesResponseMultiError) AllErrors() []error { return m }

// ListCachesResponseValidationError is the validation error returned by
// ListCachesResponse.Validate if the designated constraints aren't met.
type ListCachesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCachesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCachesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCachesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCachesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCachesResponseValidationError) ErrorName() string {
	return "ListCachesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCachesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCachesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCachesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCachesResponseValidationError{}

// Validate checks the field values on GetCacheRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetCacheRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCacheRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCacheRequestMultiError, or nil if none found.
func (m *GetCacheRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCacheRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetCacheRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetCacheRequestMultiError(errors)
	}

	return nil
}

// GetCacheRequestMultiError is an error wrapping multiple validation errors
// returned by GetCacheRequest.ValidateAll() if the designated constraints
// aren't met.
type GetCacheRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCacheRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCacheRequestMultiError) AllErrors() []error { return m }

// GetCacheRequestValidationError is the validation error returned by
// GetCacheRequest.Validate if the designated constraints aren't met.
type GetCacheRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCacheRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCacheRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCacheRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCacheRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCacheRequestValidationError) ErrorName() string { return "GetCacheRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetCacheRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCacheRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCacheRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCacheRequestValidationError{}

// Validate checks the field values on CacheResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CacheResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CacheResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CacheResponseMultiError, or
// nil if none found.
func (m *CacheResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CacheResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CacheResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CacheResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CacheResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CacheResponseValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CacheResponseValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CacheResponseValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CacheResponseMultiError(errors)
	}

	return nil
}

// CacheResponseMultiError is an error wrapping multiple validation errors
// returned by CacheResponse.ValidateAll() if the designated constraints
// aren't met.
type CacheResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CacheResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CacheResponseMultiError) AllErrors() []error { return m }

// CacheResponseValidationError is the validation error returned by
// CacheResponse.Validate if the designated constraints aren't met.
type CacheResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CacheResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CacheResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CacheResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CacheResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CacheResponseValidationError) ErrorName() string { return "CacheResponseValidationError" }

// Error satisfies the builtin error interface
func (e CacheResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCacheResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CacheResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CacheResponseValidationError{}

// Validate checks the field values on ListRateLimitsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListRateLimitsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRateLimitsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRateLimitsResponseMultiError, or nil if none found.
func (m *ListRateLimitsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRateLimitsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRateLimitsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRateLimitsResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRateLimitsResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListRateLimitsResponseMultiError(errors)
	}

	return nil
}

// ListRateLimitsResponseMultiError is an error wrapping multiple validation
// errors returned by ListRateLimitsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListRateLimitsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRateLimitsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRateLimitsResponseMultiError) AllErrors() []error { return m }

// ListRateLimitsResponseValidationError is the validation error returned by
// ListRateLimitsResponse.Validate if the designated constraints aren't met.
type ListRateLimitsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRateLimitsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRateLimitsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRateLimitsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRateLimitsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRateLimitsResponseValidationError) ErrorName() string {
	return "ListRateLimitsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListRateLimitsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRateLimitsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRateLimitsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRateLimitsResponseValidationError{}

// Validate checks the field values on GetBufferRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetBufferRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetBufferRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetBufferRequestMultiError, or nil if none found.
func (m *GetBufferRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetBufferRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetBufferRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetBufferRequestMultiError(errors)
	}

	return nil
}

// GetBufferRequestMultiError is an error wrapping multiple validation errors
// returned by GetBufferRequest.ValidateAll() if the designated constraints
// aren't met.
type GetBufferRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetBufferRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetBufferRequestMultiError) AllErrors() []error { return m }

// GetBufferRequestValidationError is the validation error returned by
// GetBufferRequest.Validate if the designated constraints aren't met.
type GetBufferRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetBufferRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetBufferRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetBufferRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetBufferRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetBufferRequestValidationError) ErrorName() string { return "GetBufferRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetBufferRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetBufferRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetBufferRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetBufferRequestValidationError{}

// Validate checks the field values on BufferResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BufferResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BufferResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BufferResponseMultiError,
// or nil if none found.
func (m *BufferResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *BufferResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BufferResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BufferResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BufferResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BufferResponseValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BufferResponseValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BufferResponseValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BufferResponseMultiError(errors)
	}

	return nil
}

// BufferResponseMultiError is an error wrapping multiple validation errors
// returned by BufferResponse.ValidateAll() if the designated constraints
// aren't met.
type BufferResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BufferResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BufferResponseMultiError) AllErrors() []error { return m }

// BufferResponseValidationError is the validation error returned by
// BufferResponse.Validate if the designated constraints aren't met.
type BufferResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BufferResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BufferResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BufferResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BufferResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BufferResponseValidationError) ErrorName() string { return "BufferResponseValidationError" }

// Error satisfies the builtin error interface
func (e BufferResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBufferResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BufferResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BufferResponseValidationError{}

// Validate checks the field values on ListBuffersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListBuffersResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListBuffersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListBuffersResponseMultiError, or nil if none found.
func (m *ListBuffersResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListBuffersResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListBuffersResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListBuffersResponseValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListBuffersResponseValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListBuffersResponseMultiError(errors)
	}

	return nil
}

// ListBuffersResponseMultiError is an error wrapping multiple validation
// errors returned by ListBuffersResponse.ValidateAll() if the designated
// constraints aren't met.
type ListBuffersResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListBuffersResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListBuffersResponseMultiError) AllErrors() []error { return m }

// ListBuffersResponseValidationError is the validation error returned by
// ListBuffersResponse.Validate if the designated constraints aren't met.
type ListBuffersResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListBuffersResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListBuffersResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListBuffersResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListBuffersResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListBuffersResponseValidationError) ErrorName() string {
	return "ListBuffersResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListBuffersResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListBuffersResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListBuffersResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListBuffersResponseValidationError{}

// Validate checks the field values on GetRateLimitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetRateLimitRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetRateLimitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetRateLimitRequestMultiError, or nil if none found.
func (m *GetRateLimitRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetRateLimitRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() <= 0 {
		err := GetRateLimitRequestValidationError{
			field:  "Id",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetRateLimitRequestMultiError(errors)
	}

	return nil
}

// GetRateLimitRequestMultiError is an error wrapping multiple validation
// errors returned by GetRateLimitRequest.ValidateAll() if the designated
// constraints aren't met.
type GetRateLimitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRateLimitRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRateLimitRequestMultiError) AllErrors() []error { return m }

// GetRateLimitRequestValidationError is the validation error returned by
// GetRateLimitRequest.Validate if the designated constraints aren't met.
type GetRateLimitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRateLimitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRateLimitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRateLimitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRateLimitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRateLimitRequestValidationError) ErrorName() string {
	return "GetRateLimitRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetRateLimitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRateLimitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRateLimitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRateLimitRequestValidationError{}

// Validate checks the field values on RateLimitResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RateLimitResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RateLimitResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RateLimitResponseMultiError, or nil if none found.
func (m *RateLimitResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RateLimitResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RateLimitResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RateLimitResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RateLimitResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RateLimitResponseValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RateLimitResponseValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RateLimitResponseValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RateLimitResponseMultiError(errors)
	}

	return nil
}

// RateLimitResponseMultiError is an error wrapping multiple validation errors
// returned by RateLimitResponse.ValidateAll() if the designated constraints
// aren't met.
type RateLimitResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RateLimitResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RateLimitResponseMultiError) AllErrors() []error { return m }

// RateLimitResponseValidationError is the validation error returned by
// RateLimitResponse.Validate if the designated constraints aren't met.
type RateLimitResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RateLimitResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RateLimitResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RateLimitResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RateLimitResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RateLimitResponseValidationError) ErrorName() string {
	return "RateLimitResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RateLimitResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRateLimitResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RateLimitResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RateLimitResponseValidationError{}

// Validate checks the field values on ListWorkersResponse_Worker with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListWorkersResponse_Worker) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListWorkersResponse_Worker with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListWorkersResponse_WorkerMultiError, or nil if none found.
func (m *ListWorkersResponse_Worker) ValidateAll() error {
	return m.validate(true)
}

func (m *ListWorkersResponse_Worker) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Address

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetLastHeartbeat()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListWorkersResponse_WorkerValidationError{
					field:  "LastHeartbeat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListWorkersResponse_WorkerValidationError{
					field:  "LastHeartbeat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastHeartbeat()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListWorkersResponse_WorkerValidationError{
				field:  "LastHeartbeat",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListWorkersResponse_WorkerMultiError(errors)
	}

	return nil
}

// ListWorkersResponse_WorkerMultiError is an error wrapping multiple
// validation errors returned by ListWorkersResponse_Worker.ValidateAll() if
// the designated constraints aren't met.
type ListWorkersResponse_WorkerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWorkersResponse_WorkerMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWorkersResponse_WorkerMultiError) AllErrors() []error { return m }

// ListWorkersResponse_WorkerValidationError is the validation error returned
// by ListWorkersResponse_Worker.Validate if the designated constraints aren't met.
type ListWorkersResponse_WorkerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWorkersResponse_WorkerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWorkersResponse_WorkerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWorkersResponse_WorkerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWorkersResponse_WorkerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWorkersResponse_WorkerValidationError) ErrorName() string {
	return "ListWorkersResponse_WorkerValidationError"
}

// Error satisfies the builtin error interface
func (e ListWorkersResponse_WorkerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWorkersResponse_Worker.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWorkersResponse_WorkerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWorkersResponse_WorkerValidationError{}
